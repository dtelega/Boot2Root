1. $ gdb bomb

2. disassemble main
Видим там вызовы функций phase_1 ... _6
и phase_defused

2. Заранее ставим брейпоинты
$ break phase_1
...
$ break phase_6

3. Дизасемблируем phase_1
$ disassemble phase_1

$ x/s  0x80497c0 константа "Public speaking is very easy."

0x08048b20 <+0>:	push   %ebp  			; сохраняем регистр
0x08048b21 <+1>:	mov    %esp,%ebp		; помещаем значение эбп в эсп
0x08048b23 <+3>:	sub    $0x8,%esp		; отнимаем значение по адресу 0х8 от регистра эсп и сохраняем в эсп
0x08048b26 <+6>:	mov    0x8(%ebp),%eax	; ?? что то связано с офсетами или indirect move (не думаю что оно нам нужно)
0x08048b29 <+9>:	add    $0xfffffff8,%esp	; сумируем 
0x08048b2c <+12>:	push   $0x80497c0		; заносим указатель на строку
0x08048b31 <+17>:	push   %eax				; заносим введенный аргумент
0x08048b32 <+18>:	call   0x8049030 <strings_not_equal> ; вызов функции с этими аргументами
0x08048b37 <+23>:	add    $0x10,%esp
0x08048b3a <+26>:	test   %eax,%eax
0x08048b3c <+28>:	je     0x8048b43 <phase_1+35>
0x08048b3e <+30>:	call   0x80494fc <explode_bomb>
0x08048b43 <+35>:	mov    %ebp,%esp	; возвращаем значение стека
0x08048b45 <+37>:	pop    %ebp			; 
0x08048b46 <+38>:	ret


4. Дизасемблируем phase_2
   0x08048b48 <+0>:	push   %ebp
   0x08048b49 <+1>:	mov    %esp,%ebp
   0x08048b4b <+3>:	sub    $0x20,%esp
   0x08048b4e <+6>:	push   %esi
   0x08048b4f <+7>:	push   %ebx
   0x08048b50 <+8>:	mov    0x8(%ebp),%edx
   0x08048b53 <+11>:	add    $0xfffffff8,%esp
   0x08048b56 <+14>:	lea    -0x18(%ebp),%eax
   0x08048b59 <+17>:	push   %eax
   0x08048b5a <+18>:	push   %edx
   0x08048b5b <+19>:	call   0x8048fd8 <read_six_numbers>
   0x08048b60 <+24>:	add    $0x10,%esp
   0x08048b63 <+27>:	cmpl   $0x1,-0x18(%ebp)
   0x08048b67 <+31>:	je     0x8048b6e <phase_2+38>
   0x08048b69 <+33>:	call   0x80494fc <explode_bomb>
   0x08048b6e <+38>:	mov    $0x1,%ebx
   0x08048b73 <+43>:	lea    -0x18(%ebp),%esi
   0x08048b76 <+46>:	lea    0x1(%ebx),%eax
   0x08048b79 <+49>:	imul   -0x4(%esi,%ebx,4),%eax
   0x08048b7e <+54>:	cmp    %eax,(%esi,%ebx,4)
   0x08048b81 <+57>:	je     0x8048b88 <phase_2+64>
   0x08048b83 <+59>:	call   0x80494fc <explode_bomb>
   0x08048b88 <+64>:	inc    %ebx
   0x08048b89 <+65>:	cmp    $0x5,%ebx
   0x08048b8c <+68>:	jle    0x8048b76 <phase_2+46>
   0x08048b8e <+70>:	lea    -0x28(%ebp),%esp
   0x08048b91 <+73>:	pop    %ebx
   0x08048b92 <+74>:	pop    %esi
   0x08048b93 <+75>:	mov    %ebp,%esp
   0x08048b95 <+77>:	pop    %ebp
   0x08048b96 <+78>:	ret


0x08048b5b <+19>:	call   0x8048fd8 <read_six_numbers>   ; читаем с клавиатуры числа и записываем их в регистры
0x08048b60 <+24>:	add    $0x10,%esp 					
0x08048b63 <+27>:	cmpl   $0x1,-0x18(%ebp)				; сравниваем первое число с 1 и если не развно, бомба взрываеться
0x08048b67 <+31>:	je     0x8048b6e <phase_2+38>		; 
0x08048b69 <+33>:	call   0x80494fc <explode_bomb>		;
0x08048b6e <+38>:	mov    $0x1,%ebx					; в эбх занесли 1
0x08048b73 <+43>:	lea    -0x18(%ebp),%esi				; 
0x08048b76 <+46>:	lea    0x1(%ebx),%eax
0x08048b79 <+49>:	imul   -0x4(%esi,%ebx,4),%eax		;; ??? с этой арифметикой еще нужно разобраться
0x08048b7e <+54>:	cmp    %eax,(%esi,%ebx,4)			
0x08048b81 <+57>:	je     0x8048b88 <phase_2+64>
0x08048b83 <+59>:	call   0x80494fc <explode_bomb>
0x08048b88 <+64>:	inc    %ebx							; увеличиваем эбх
0x08048b89 <+65>:	cmp    $0x5,%ebx					; возвращаемся на 46 строку если эбх меньше или равен 5 
0x08048b8c <+68>:	jle    0x8048b76 <phase_2+46>

subl -0x20(%ebx,%ecx,0x4),%eax (AT&T)  # записать в EAX значение (ECX * 4) + EBX - 32




5. Дизасемблируем phase_3
Dump of assembler code for function phase_3:
   0x08048b98 <+0>:	push   %ebp
   0x08048b99 <+1>:	mov    %esp,%ebp
   0x08048b9b <+3>:	sub    $0x14,%esp
   0x08048b9e <+6>:	push   %ebx
   0x08048b9f <+7>:	mov    0x8(%ebp),%edx
   0x08048ba2 <+10>:	add    $0xfffffff4,%esp
   0x08048ba5 <+13>:	lea    -0x4(%ebp),%eax
   0x08048ba8 <+16>:	push   %eax
   0x08048ba9 <+17>:	lea    -0x5(%ebp),%eax
   0x08048bac <+20>:	push   %eax
   0x08048bad <+21>:	lea    -0xc(%ebp),%eax
   0x08048bb0 <+24>:	push   %eax
   0x08048bb1 <+25>:	push   $0x80497de
   0x08048bb6 <+30>:	push   %edx
   0x08048bb7 <+31>:	call   0x8048860 <sscanf@plt>
   0x08048bbc <+36>:	add    $0x20,%esp
   0x08048bbf <+39>:	cmp    $0x2,%eax
   0x08048bc2 <+42>:	jg     0x8048bc9 <phase_3+49>
   0x08048bc4 <+44>:	call   0x80494fc <explode_bomb>
   0x08048bc9 <+49>:	cmpl   $0x7,-0xc(%ebp)
   0x08048bcd <+53>:	ja     0x8048c88 <phase_3+240>
   0x08048bd3 <+59>:	mov    -0xc(%ebp),%eax
   0x08048bd6 <+62>:	jmp    *0x80497e8(,%eax,4)
   0x08048bdd <+69>:	lea    0x0(%esi),%esi
   0x08048be0 <+72>:	mov    $0x71,%bl
   0x08048be2 <+74>:	cmpl   $0x309,-0x4(%ebp)
   0x08048be9 <+81>:	je     0x8048c8f <phase_3+247>
   0x08048bef <+87>:	call   0x80494fc <explode_bomb>
   0x08048bf4 <+92>:	jmp    0x8048c8f <phase_3+247>
   0x08048bf9 <+97>:	lea    0x0(%esi,%eiz,1),%esi
   0x08048c00 <+104>:	mov    $0x62,%bl
   0x08048c02 <+106>:	cmpl   $0xd6,-0x4(%ebp)
   0x08048c09 <+113>:	je     0x8048c8f <phase_3+247>
   0x08048c0f <+119>:	call   0x80494fc <explode_bomb>
   0x08048c14 <+124>:	jmp    0x8048c8f <phase_3+247>
   0x08048c16 <+126>:	mov    $0x62,%bl
   0x08048c18 <+128>:	cmpl   $0x2f3,-0x4(%ebp)
   0x08048c1f <+135>:	je     0x8048c8f <phase_3+247>
   0x08048c21 <+137>:	call   0x80494fc <explode_bomb>
   0x08048c26 <+142>:	jmp    0x8048c8f <phase_3+247>
   0x08048c28 <+144>:	mov    $0x6b,%bl
   0x08048c2a <+146>:	cmpl   $0xfb,-0x4(%ebp)
---Type <return> to continue, or q <return> to quit---
   0x08048c31 <+153>:	je     0x8048c8f <phase_3+247>
   0x08048c33 <+155>:	call   0x80494fc <explode_bomb>
   0x08048c38 <+160>:	jmp    0x8048c8f <phase_3+247>
   0x08048c3a <+162>:	lea    0x0(%esi),%esi
   0x08048c40 <+168>:	mov    $0x6f,%bl
   0x08048c42 <+170>:	cmpl   $0xa0,-0x4(%ebp)
   0x08048c49 <+177>:	je     0x8048c8f <phase_3+247>
   0x08048c4b <+179>:	call   0x80494fc <explode_bomb>
   0x08048c50 <+184>:	jmp    0x8048c8f <phase_3+247>
   0x08048c52 <+186>:	mov    $0x74,%bl
   0x08048c54 <+188>:	cmpl   $0x1ca,-0x4(%ebp)
   0x08048c5b <+195>:	je     0x8048c8f <phase_3+247>
   0x08048c5d <+197>:	call   0x80494fc <explode_bomb>
   0x08048c62 <+202>:	jmp    0x8048c8f <phase_3+247>
   0x08048c64 <+204>:	mov    $0x76,%bl
   0x08048c66 <+206>:	cmpl   $0x30c,-0x4(%ebp)
   0x08048c6d <+213>:	je     0x8048c8f <phase_3+247>
   0x08048c6f <+215>:	call   0x80494fc <explode_bomb>
   0x08048c74 <+220>:	jmp    0x8048c8f <phase_3+247>
   0x08048c76 <+222>:	mov    $0x62,%bl
   0x08048c78 <+224>:	cmpl   $0x20c,-0x4(%ebp)
   0x08048c7f <+231>:	je     0x8048c8f <phase_3+247>
   0x08048c81 <+233>:	call   0x80494fc <explode_bomb>
   0x08048c86 <+238>:	jmp    0x8048c8f <phase_3+247>
   0x08048c88 <+240>:	mov    $0x78,%bl
   0x08048c8a <+242>:	call   0x80494fc <explode_bomb>
   0x08048c8f <+247>:	cmp    -0x5(%ebp),%bl
   0x08048c92 <+250>:	je     0x8048c99 <phase_3+257>
   0x08048c94 <+252>:	call   0x80494fc <explode_bomb>
   0x08048c99 <+257>:	mov    -0x18(%ebp),%ebx
   0x08048c9c <+260>:	mov    %ebp,%esp
   0x08048c9e <+262>:	pop    %ebp
   0x08048c9f <+263>:	ret



   0x80497de ====== "%d %c %d"
   Значит нужно ввести число, символ, число

   0x08048bbf <+39>:	cmp    $0x2,%eax
   0x08048bc2 <+42>:	jg     0x8048bc9 <phase_3+49>
   От 2-ки отнимаеться значение еах
   В еах походу лежит первое введеное число
   jg если 2 - еах > 0 то все ок, иначе бомба взрываеться



